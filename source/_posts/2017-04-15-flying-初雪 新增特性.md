---
layout: post
title: flying-初雪 新增内容
description: 本节内容向您讲解初雪版本新增的自定义主键生成器和“或”查询特性
category: blog
date: 2017-04-15
list_number: false
---
`初雪` 对应 flying 版本号为 `0.8.3`（适用于 mybatis-3.3.x）和 `0.9.3`（适用于 mybatis-3.4.x），主要新增特性如下：

## [自定义主键生成器](#自定义主键生成器)
为满足个性化主键需要，flying 新增了自定义主键生成器，为此我们在flying:insert语句中新增了括号元素，如下：
```xml
flying:insert(uuid)                      使用标准uuid作主键
flying:insert(uuid_no_line)              使用无下横线的uuid作主键
flying:insert(millisecond)               使用毫秒数作主键（需保证每秒并发在1000以下）
```
当然更多的情况是您会自定义自己的主键生成器，只要您的主键生成器实现了 flying 中的 indi.mybatis.flying.type.KeyHandler 接口即可，比如这样调用一个自定义的主键生成器类：
```xml
flying:insert(indi.mybatis.flying.handlers.MySnowFlakeKeyHandler)
```
（上面的 indi.mybatis.flying.handlers.MySnowFlakeKeyHandler 是一个雪花主键生成器的 java 版本实现。雪花主键生成器由 tweeter 发明用于处理大规模并行写入，主键采用 float 类型存储以节省资源，自带递增无需 order by，单台主机每秒可产生 400 万个不同主键，最多可 1024 台主机集群同时工作。flying 中提供了一个实现方式，[代码见此](https://gitee.com/limeng32/mybatis.flying/blob/master/src/main/java/indi/mybatis/flying/handlers/SnowFlakeKeyHandler.java)）

在某些特殊业务场景中，您需要使用主键表达一定的业务含义，这时自定义主键生成器会显得非常有效。

这里有一个[使用了自定义主键生成器的例子](https://gitee.com/limeng32/flying-demo2/tree/use-flying-0.9.3/)，相信您看完以后会对此特性了然于胸。

## [使用或逻辑查询](#使用或逻辑查询)

### [普通或逻辑查询](#普通或逻辑查询)
“或”逻辑查询是 `初雪` 版本新增的最重要内容。为了实现此特性 flying 新增了 Or 标签类（[代码见此](https://gitee.com/limeng32/mybatis.flying/blob/master/src/main/java/indi/mybatis/flying/annotations/Or.java)），这个标签的内容是ConditionMapperAnnotation标签的数组，所以在查询条件类中可以有如下标签代码：
```java
@Or({
  @ConditionMapperAnnotation(dbFieldName = "name", conditionType = ConditionType.HeadLike),
  @ConditionMapperAnnotation(dbFieldName = "age", conditionType = ConditionType.Equal), 
  @ConditionMapperAnnotation(dbFieldName = "name", conditionType = ConditionType.HeadLike) 
})
```
（上面是实现 name like 'XXX%' or age = 'YYY' or name like 'ZZZ%' 查询的条件）

同时为了赋值方便，我们采用Object数组的不定参数形式作为变量类型，于是整个代码变成了：
```java
@Or({
  @ConditionMapperAnnotation(dbFieldName = "name", conditionType = ConditionType.HeadLike),
  @ConditionMapperAnnotation(dbFieldName = "age", conditionType = ConditionType.Equal), 
  @ConditionMapperAnnotation(dbFieldName = "name", conditionType = ConditionType.HeadLike) 
})
private Object[] condition1;

public Object[] getCondition1 () {
	return condition1;
}
public void setCondition1 (Object... condition1) {
	this. condition1 = condition1;
}
```
如果我们描述 "name like '张%' or age = 27 or name like '李%' "，代码如下：
```java
personCondition.setCondition1("张", 27, "李");
/* 注意参数顺序和 condition1 上 @ConditionMapperOrAnnotation 的内部顺序一致 */
```
您之前掌握的[绝大部分 ConditionMapperAnnotation](https://gitee.com/limeng32/mybatis.flying/blob/master/src/main/java/indi/mybatis/flying/statics/ConditionType.java) 都可以写在 `@Or` 中，只有本身就是集合型的条件类型例外，以下列出不能进入 `@Or` 的类型：

`MultiLikeAND`、`MultiLikeOR`、 `In`、`NotIn`

除此之外的查询条件均可以参与或查询。

### [外键或逻辑查询](#外键或逻辑查询)
flying 在同库跨表查询时也可以做不同表上条件的或逻辑查询，比如我们要实现 person.name = 'XXX' or role.name = 'YYY' 查询，其中 role 是 person 业务上的父对象。我们可以在 role 的条件类中加入如下变量：
```java
@Or({ 
  @ConditionMapperAnnotation(dbFieldName = "name", conditionType = ConditionType.Equal),
  @ConditionMapperAnnotation(dbFieldName = "name", conditionType = ConditionType.Equal, subTarget = mypackage.Person.class) })
private Object[] roleNameEqualsOrPersonNameEquals;

public Object[] getRoleNameEqualsOrPersonNameEquals () {
	return roleNameEqualsOrPersonNameEquals;
}
public void setRoleNameEqualsOrPersonNameEquals (Object... roleNameEqualsOrPersonNameEquals) {
	this. roleNameEqualsOrPersonNameEquals = roleNameEqualsOrPersonNameEquals;
}
```
上面的代码中第一行 `ConditionMapperAnnotation` 指的是 role 表，第二行指的是 person 表，因为是由 role 指向 person，所以第二行出现了 `subTarget` 参数用来引导路径，它的值就是业务上子对象的类路径。

值得注意的是，外键或逻辑查询中，跨表的 `@Or` 条件永远要写在业务上的父对象里，这是考虑到从子对象上寻找父对象并非唯一（例如多重外键情况，一个 person 有多个 role 型父对象，分别表示主要角色和次要角色等），然而从父对象上寻找子对象永远是唯一的。

如果您要查询用户名为“张三”或角色名为“wfadmin”的用户时，您应该这样做：
```java
RoleConditon rc = new RoleCondition();
rc.setRoleNameEqualsOrPersonNameEquals("wfadmin","张三");
Person p = new Person();
p.setRole(rc);
Person<Collection> persons = personService.selectAll(p);
```
无论 role 是 person 业务上的直接父对象还是间接父对象都可以这样查询。

### [跨库或逻辑查询](#跨库或逻辑查询)
或查询也可以用在跨库查询中，但仅限于外键 ID 相等这一种条件。我们假设 person 和 role 不在一个数据库中，如果想查询对应role 的 ID 为 1 或者为 2 的 person，我们可以在 person 的条件类中加入如下变量：
```java
@Or({ 
  @ConditionMapperAnnotation(dbFieldName = "role_id", conditionType = ConditionType.Equal, dbAssociationTypeHandler = mypackage.typeHandler.RoleTypeHandler.class),
  @ConditionMapperAnnotation(dbFieldName = "role_id", conditionType = ConditionType.Equal, dbAssociationTypeHandler = mypackage.typeHandler.RoleTypeHandler.class) })
private Object[] role1EqualsOrRole2Equals;

public Object[] getRole1EqualsOrRole2Equals () {
	return role1EqualsOrRole2Equals;
}
public void setRole1EqualsOrRole2Equals (Object... role1EqualsOrRole2Equals) {
	this. role1EqualsOrRole2Equals = role1EqualsOrRole2Equals;
}
```

关于跨库的实现方案您可以参见[使用 flying 跨数据源查询](http://flying-doc.limeng32.com/2017/05/01/2017-05-01-%E4%BD%BF%E7%94%A8flying%E8%A7%A3%E5%86%B3pojo%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98/#%E8%B7%A8%E6%95%B0%E6%8D%AE%E6%BA%90)一节，`@ConditionMapperAnnotation` 中的 `dbAssociationTypeHandler` 属性和 `@FieldMapperAnnotation` 中的 `dbAssociationTypeHandler` 完全相同。

如果想查询对应role 的 ID 为 1 或者为 2 的 person 的话只需如下代码即可：

```java
Role r1 = new Role();
r1.setId(1);
Role r2 = new Role();
r2.setId(2);
PersonCondition pc = new PersonCondition();
pc.setRole1EqualsOrRole2Equals(r1,r2);
Person<Collection> persons = personService.selectAll(pc);
```
## [全面提升代码质量](#全面提升代码质量)
在 `初雪` 中，我们把代码质量作为提升的重要一环，同时使用 阿里 P3C 和 SonarQube 来修正代码缺陷，当您阅读 flying 源码时您会深切感受到这一点。